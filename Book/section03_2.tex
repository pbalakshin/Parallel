\subsection{Менеджеры управления памятью для параллельных программ}

При вызове функций malloc/free в однопоточной программе не возникает проблем даже при довольно высокой интенсивности вызовов одной из них. Однако в параллельных программах эти функции могут стать узким местом, т.к. при их одновременном использовании из нескольких потоков происходит блокировка общего ресурса (менеджера управления памятью), что может привести к существенной деградации скорости работы многопоточной программы.

Получается, что несмотря на формальную потокобезопасность стандартных функций работы с памятью, они могут стать потоконеэффективными при очень интенсивной работе с памятью нескольких параллельно работающих потоков.

Для решения этой проблемы существует ряд сторонних программ, называющихся <<Менеджер управления памятью (МУП)>> (Memory Al\-lo\-ca\-tor), как платных, так и бесплатных с открытым исходным кодом. Каждое из них обладает своими достоинствами и недостатками, которые следует учитывать при выборе. Перечислим наиболее распространённые МУП с указанием ссылок на официальные сайты:

\begin{itemize}
    \item tcmalloc: \url{http://goog-perftools.sourceforge.net/doc/tcmalloc.html}
    \item ptmalloc: \url{http://www.malloc.de/malloc/ptmalloc3-current.tar.gz}
    \item dmalloc: \url{http://dmalloc.com}
    \item HOARD: \url{http://www.hoard.org}
    \item nedmalloc: \url{http://www.nedprod.com/programs/portable/nedmalloc}
    \item jemalloc: \url{http://jemalloc.net}
    \item mimalloc: \url{https://github.com/microsoft/mimalloc}
\end{itemize}

Перечисленные МУП разработаны таким образом, что ими можно <<незаметно>> для параллельной программы подменить стандартные МУП библиотеки libc языка С. Это значит, что выбор конкретного МУП никак не влияет на исходный код программы, поэтому общая практика использования сторонних МУП такова: параллельная программа изначально создаётся с использованием МУП libc, затем проводится профилирование работающей программы, затем при обнаружении узкого места (bottleneck) в функциях malloc/free принимается решение заменить стандартный МУП одним из перечисленных.

Также стоит отметить, что некоторые технологии распараллеливания (например, Intel TBB) уже имеют в своём составе специализированный МУП, оптимизированный для выполнения в многопоточном режиме.
