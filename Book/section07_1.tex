\subsection{Порядок выполнения работы}
\begin{enumerate}
    \itemДобавить во все for-циклы (кроме цикла в функции main, указывающего количество экспериментов) в программе из ЛР №1 следующую директиву OpenMP:
    \mint{c++}|#pragma omp parallel for default(none) private(...) shared(...)|
    Наличие параметра \code{default(none)} является обязательным.
    
    \itemПроверить все for-циклы на внутренние зависимости по данным между итерациями. Если зависимости обнаружились, использовать для защиты критических секций директиву <<\#pragma omp critical>> или <<\#pragma omp atomic>> (если операция атомарна), или параметр reduction (предпочтительнее), или вообще отказаться от распараллеливания цикла (свой выбор необходимо обосновать).
    
    \itemУбедиться, что получившаяся программа обладает свойством прямой совместимости с компиляторами, не поддерживающими OpenMP (для проверки этого можно скомпилировать программу без опции <<–fopenmp>>, в результате не должно быть сообщений об ошибках, а программа должна корректно работать).
    
    \itemИспользовать функцию SetNumThreads для изменения числа потоков. В отчете указать максимальное количество потоков.
    
    \itemПровести эксперименты, замеряя параллельное ускорение. Привести сравнение графиков параллельного ускорения с ЛР~№1 и ЛР~№2.
    
    \itemПровести эксперименты, добавив параметр <<schedule>> и варьируя в экспериментах тип расписания. Исследование нужно провести для всех возможных расписаний: static, dynamic, guided. Следующей <<степенью свободы>>, которую необходимо использовать, является chunck\_size, которому необходимо задать четыре различных варианта: единице, меньше чем число потоков, равному числу потоков и больше чем число потоков. Привести сравнение параллельного ускорения при различных расписаниях с результатами п.~5.
    
    \itemОпределить, какой тип расписания на вычислительной машине при использовании <<schedule default>>.
    
    \itemВыбрать из рассмотренных в п.~5 и п.~6 наилучший вариант при различных N. Сформулировать условия, при которых наилучшие результаты получились бы при использовании других типов расписания.
    
    \itemНайти вычислительную сложность алгоритма до и после распараллеливания, сравнить полученные результаты.
    
    \itemДля иллюстрации того, что программа действительно распараллелилась, привести график загрузки процессора (ядер) от времени при выполнении программы при $N = N_1$ для лучшего варианта распараллеливания. Для получения графика можно как написать скрипт, так и просто сделать скриншот диспетчера задач, указав на скриншоте моменты начала и окончания эксперимента (в отчёте нужно привести текст скрипта или название использованного диспетчера). Недостаточно привести однократное моментальное измерение загрузки утилитой htop, т.к. требуется привести график изменения загрузки за всё время выполнения программы.
    
    \itemНаписать отчёт о проделанной работе.
    
    \itemПодготовиться к устным вопросам на защите.
    
    \item\textbf{Необязательное задание №1 (для получения оценки <<4>> и <<5>>).} Построить график параллельного ускорения для точек $N < N_1$ и найти значения $N$, при которых накладные расходы на распараллеливание превышают выигрыш от распараллеливания (независимо для различных типов расписания).
    
    \item \textbf{Необязательное задание №2 (для получения оценки <<5>>).} Для лучшего результата по итогам всех экспериментов сделать еще минимум три эксперимента, заменив флаг <<-O3>> на другие флаги оптимизации. Построить график времени выполнения от $N$.
\end{enumerate}