\subsection{POSIX Threads}
\label{PThreads:section}

\textbf{Потоки POSIX.} 

В данной библиотеке более 100 разных функций, но всех их можно разделить на 4 основные группы:

\begin{itemize}
    \itemУправление потоками: create, join и т.д.
    \itemМьютексы.
    \itemУсловные переменные.
    \itemСинхронизация между тредами.
\end{itemize}

Для того, чтобы воспользоваться библиотекой PThreads в Unix-like и POSIX-совместимой операционной системе, достаточно подключить следующий заголовочный файл PThreads: 
\mint{c++}|#include <pthread.h>|

В отличие от OpenMP, PThreads является более низкоуровневой библиотекой, где от разработчика требуется заранее продумать всю логику работы потоков.

Рассмотрим задачу добавление числа 10 к каждому элементу массива:

\begin{minted}{c++}
for (int i=0; i<N; i++)
    array[i] = array[i] + 10;
\end{minted}

Теперь воспользуемся библиотекой PThreads для распараллеливания данной задачи (для понимания того, что происходит, приведен код всей программы):

\inputminted{c++}{listings/WithPosix.c}

Теперь разберем, что происходит в данной программе. Начнем с инициализации тредов:

\begin{minted}{c++}
// First option
pthread_t thread_1, thread_2;

// Second option
pthread_t threads[2];
\end{minted}

В данном коде представлено два варианта того, как можно инициализировать несколько потоков. Это может быть как отдельная переменная, так и массив потоков.

После инициализации необходимо создать поток:

\begin{minted}{c++}
if (pthread_create(&thread_1, NULL, plus_ten, &ptrFirst) == -1)
    printf("Поток 1 не создан.");
\end{minted}

Функция pthread\_create принимает четыре параметра: указатель на поток, атрибуты потока (если используются атрибуты по умолчанию, то передается NULL), функция которую будет выполнять поток, аргумент функции.

В случае, если поток успешно создан, возвращается 0. Иначе могут быть вовзращены следующие значения:

\begin{itemize}
    \item EAGAIN – у системы нет ресурсов для создания нового потока, или система не может больше создавать потоков, так как число потоков превысило значение \\ PTHREAD\_THREADS\_MAX\@.
    \item EINVAL – неправильные атрибуты потока (переданные аргументом attr).
    \item EPERM – Вызывающий поток не имеет должных прав для того, чтобы задать нужные параметры или политики планировщика.
\end{itemize}

Все коды ошибок можно изучить по данной ссылке \url{https://www-numi.fnal.gov/offline_software/srt_public_context/WebDocs/Errors/unix_system_errors.html}.

Аргумент функции должен быть типа \code{void*}. Чтобы передать несколько параметров, их необходимо обернуть в структуру. В нашем случае необходимо передать указатель на массив и интервал, на котором необходимо провести вычисления:

\begin{minted}{c++}
typedef struct {
    int* array;
    int start, end;
} part_of_array;
\end{minted}

Сразу после того, как поток создан, он начинает выполнение. По стандарту выход из функции вызывает функцию pthread\_exit, а возвращаемое значение будет передано при вызове pthread\_join, как статус.

В свою очередь, функция pthread\_join заставляет основной поток ожидать завершения порожденных им потоков.

При успешном завершении потока функция pthread\_join возвращает 0, иначе данная функция может вывести следующие ошибки:

\begin{itemize}
    \item EINVAL – thread указывает на не объединяемый поток.
    \item ESRCH – не существует потока с таким идентификатором, который хранит переменная thread.
    \item EDEADLK – был обнаружен дедлок (взаимная блокировка), или же в качестве объединяемого потока указан сам вызывающий поток.
\end{itemize}

\textbf{Механизмы синхронизации потоков.} Взаимное исключение \textit{mu\-tex} выполняет функцию ограничения доступа потоков к одному ресурсу. Mutex - переменная, которая может быть или заблокирована, или свободна. При этом, если один поток её заблокировал, другие потоки будут ожидать освобождения ресурса.

\begin{minted}{c++}
// Initialize mutex
int pthread_mutex_init(pthread_mutex_t *mutex, 
                       const pthread_mutexattr_t *mutexattr);

// Lock resource
int pthread_mutex_lock(pthread_mutex_t *mutex);

// Free resource
int pthread_mutex_unlock(pthread_mutex_t *mutex);

// Delete mutex
int pthread_mutex_destroy(pthread_mutex_t *mutex);
\end{minted}

\code{pthread_mutex_t} тип данных описывающий mutex. Атрибуты mutex можно контролировать функцией \code{pthread_mutex_init()}.

Рассмотрим пример функции, в которой необходима синхронизация:

\inputminted{c++}{listings/WithoutMutex.c}

Данная программа добавляет значения элементов массива в глобальную переменную sum, при обращении нескольких потоков к данной переменной конечный результат может измениться.

Необходимо добавить mutex в данную функцию, который бы ограничил доступ к данной переменной одновременно нескольким потокам. Тогда программа будет выглядеть следующим образом:

\inputminted{c++}{listings/WithMutex.c}

\textbf{Семафор.} Следующим примитивом синхронизации является семафор. Его задача такая же, как и у mutex, главное отличие в том, что mutex захватывает один поток в то время, как семафор может захватывать несколько потоков.

Чтобы воспользоваться семафором, необходимо подключить заголовочный файл:
\mint{c++}{#include <semaphore.h>}

Важно, что семафор после окончания работы с ним необходимо удалять, как это показано ниже:

\begin{minted}{c++}
int sem_init(sem_t *sem, int pshared, unsigned int value);
int sem_destroy(sem_t *sem);
\end{minted}

Функция \code{sem_init()} принимает следующие параметры: sem - объект который необходимо инициализировать, pshared - (0) данный семафор будет общим для всех потоков, (1) общим для процессов, value - начальное значение семафора.

% Подробнее об остальных особенностях POSIX Threads можно прочитать в источниках~\cite{PThreadsHabr,PThreadsLibs}.

Подробнее об остальных особенностях POSIX Threads можно прочитать на следующих ресурсах:

\begin{enumerate}
    \item Статья habr: \url{https://habr.com/ru/post/326138/}
    \item Сайт со всей необходимой документацией: \url{https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html}
\end{enumerate}
