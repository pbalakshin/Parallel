\subsection{Порядок выполнения работы}
\begin{enumerate}
    \itemВ программе, полученной в результате выполнения ЛР №3, так изменить этап Generate, чтобы генерируемый набор случайных чисел не зависел от числа потоков, выполняющих программу. Например, на каждой итерации i перед вызовом \code{rand_r} можно вызывать функцию \code{srand(f(i))}, где f -– произвольно выбранная функция. Можно придумать и использовать любой другой способ.
    
    \itemЗаменить вызовы функции \code{gettimeofday} на \code{omp_get_wtime}.
    
    \itemРаспараллелить вычисления на этапе Sort, для чего выполнить сортировку в два этапа: 
    \begin{itemize}
        \itemОтсортировать первую и вторую половину массива в двух независимых нитях (можно использовать OpenMP-ди\-рек\-ти\-ву <<parallel sections>>).
        \itemОбъединить отсортированные половины в единый массив.
    \end{itemize}
    
    \itemНаписать функцию, которая один раз в секунду выводит в консоль сообщение о текущем проценте завершения работы программы. Указанную функцию необходимо запустить в отдельном потоке, параллельно работающем с основным вычислительным циклом. Нельзя использовать PThreads, сделать только средствами OpenMP.
    
    \itemОбеспечить прямую совместимость (forward compatibility) написанной параллельной программы. Для этого все вызываемые функции вида <<omp\_*>> можно условно переопределить в препроцессорных директивах, например, так:
    
    \begin{minted}{c++}
    #ifdef _OPENMP
        #include <omp.h>
    #else
        int omp_get_num_procs() { return 1; }
    #endif
    \end{minted}
    
    \itemПровести эксперименты, варьируя $N$ от $\min({N_x}/{2}, N_1)$ до $N_2$, где значения $N_1$ и $N_2$ взять из ЛР №1, а $N_x$ –- это такое значение $N$, при котором накладные расходы на распараллеливание превышают выигрыш от распараллеливания. Написать отчёт о проделанной работе. Подготовиться к устным вопросам на защите.
    
    \item\textbf{Необязательное задание №1 (для получения оценки <<4>> и <<5>>).} Уменьшить число итераций основного цикла с 100 до 10 и провести эксперименты, замеряя время выполнения следующими методами: 
        \begin{itemize}
            \itemИспользование минимального из десяти полученных замеров. 
            \itemРасчёт по десяти измерениям доверительного интервала с уровнем доверия 95\%.
        \end{itemize}
        Привести графики параллельного ускорения для обоих методов в одной системе координат, при этом нижнюю и верхнюю границу доверительного интервала следует привести двумя независимыми графиками.
    
    \item\textbf{Необязательное задание №2 (для получения оценки <<5>>).} В п.~3 задания на этапе Sort выполнить параллельную сортировку не двух частей массива, а $k$ частей в $k$ нитях (тредах), где $k$ –- это число процессоров (ядер) в системе, которое становится известным только на этапе выполнения программы с помощью команды:
    \mint{c++}{int k = omp_get_num_procs()}
\end{enumerate}
