Условные обозначения:
=fixed - поправлено
=in discuss - в обсуждении
=not needed - решено ничего не менять
=to fix - пофиксить
-------------------------------------- этап разработки
P.S. используй для поиска по документу

1. 10.09.2019. Мария Румянцева: "с. 70, условие первой лабораторной, п. 5. В предыдущем пункте мы присваиваем переменной К хотя бы 4 значения, то есть по идее количество программ у нас от 4 до бесконечности, а в условии - чётко 10."
11.09.2019. Балакшин П.В. Да, верно. Должно быть "В результате получится одна нераспараллеленная программа и 4+ распараллеленных."
=fixed

2. 10.09.2019. Мария Румянцева: "с. 73, этап Map, действия с массивом М2. Тут возник вопрос в том, что при сложении с предыдущим элементом нам нужно изначальное его значение или вычисленное на предыдущем этапе. Если вычисленное на предыдущем этапе, то похоже, стоит это указать, потому что у нас вопросы всё-таки возникли, ибо это не будет параллелиться. :)"
11.09.2019. Балакшин П.В. Мы в своё время решили, что у вас должен быть ещё один массив (= копия исходного массива). Т.е. надо просто поподробнее расписать.
=fixed

3. 10.09.2019. Мария Румянцева: "В табличке на той же странице в пункте 1 куда-то улетел минус и двойка в имени массива в M2[i-1]"
11.09.2019. Балакшин П.В. Да, верно. Должно быть "... + M2[i-1])..."
=fixed

4. 11.09.2019. Балакшин П.В. В 1-й лабораторной в пунктах 3 и 4 использовать ключ -O3, а не -O2.
=fixed

5. 12.09.2019 Азат Карапетян. "В первой лабораторной работе по параллельным вычислениям требуется создать одномерный массив длиною N? Или все же двумерный массив NxN?"
13.09.2019. Балакшин П.В. В примере программы указать, что это одномерный массив размерностью N.
=fixed

6. 12.09.2019 Александр Пашнин. "В пункте 12 "Необязательное задание №2" для icc указан неактуальный ключ -par-report, вместо него следует использовать -qopt-report-phase=par"
13.09.2019. Балакшин П.В. Дописать, что в случае, если ключ -par-report не работает, то желательно попробовать более актуальный ключ -qopt-report-phase=par.
=fixed

7. 13.09.2019. Балакшин П.В. В первой лабе проверить, что число итераций везде =50.
=fixed

8. 11.09.2019. Алексей Мишенёв. "стр. 12 определение thread-safe "Внутри функций обращение ко всем общим переменным осуществляется строго последовательно а не непараллельно". Кажется, здесь должно быть просто "строго последовательно а не параллельно".
13.09.2019. Балакшин П.В. Верно. Должно быть "строго последовательно, а не параллельно".
=fixed

9. 13.09.2019. Алексей Мишенёв. "11 стр. ОС сама решает как распорядит_ся процессорным временем".
13.09.2019. Балакшин П.В. Верно. Должно быть с мягким знаком.
=fixed

10. 13.09.2019. Алексей Мишенёв. "стр. 22 в примере с gcc -О2".
13.09.2019. Балакшин П.В. Верно. Должен быть ключ -O3.
=fixed

11. 13.09.2019. Алексей Мишенёв. Сделать человеческими ссылки на Википедию с списке литературы.
невозможно из-за ограничений пакета
Попробуй так:
\href{https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F}{https://ru.wikipedia.org/wiki/Параллельные\_вычисления}
=fixed

12. 16.09.2019. Владимир Губарев. Гипертрейдинг (hypertrading) -> гипертрединг (hyperthreading)
=fixed

13. 16.09.2019. Владимир Губарев. На таких системах *проводяться*
=fixed

14. 16.09.2019. Владимир Губарев. Частным случаем атомарных операций являются read-modify-write, compare-and-swap, test-and-set, fetch-and-add.
Если я правильно понимаю, отдельной операции RMW не существует, это класс операций, к которым относится CAS, TAS, FAA
=fixed

15. 16.09.2019. Владимир Губарев. так как накладные *расзоды*
=fixed

16. 16.09.2019. Владимир Губарев. не выходит из семафора при окончании выполнения области кода если программист забыл освободить ресурс.
Запятая
=fixed

17. 16.09.2019. Владимир Губарев. Мьютекс - частный случай семафора, при котором данную область кода может захватывать только один поток.

    17.1. Может, "в критическую секцию может входить только один поток"? Или даже в одну из критических секций, т.к. мьютекс может обслуживать сразу несколько.
    Надо переписать весь абзац про мьютекс.
    recursive_mutex - плохой стиль программирования
    =to be discussed internally
    17.2. Возможно, стоит более явно указать, что самое важное (скоре, идиологическое) отличие мьютекса от одноместного семафора в том, что мьютекс обязан быть освобожден тем потоком, который его захватил.
    Дополнить, что всё-таки есть гораздо больше отличий между семафором и мьютексом. Выделить, что они идеологически являются разными сущностями.
    =to be discussed internally
    17.3. Далее по тексту: "так как ”легче” классического семафора". Честно говоря, неочевидно, почему так?
    "легче классического семаформа" - плохая фраза, расшифровать и переделать.
    =to be discussed internally
	
18. 16.09.2019. Владимир Губарев. повторные захваты участка кода этим же потоком
Повторный вход в критическую секцию?
=fixed

19. 16.09.2019. Владимир Губарев. Внутри секции кода необходимо избегать прерываний, чтобы избежать deadlock’a.
Прерывание как сигнал или как, например, pthread_cancel? Если имеется ввиду первое и это, например, sleep, то это не приведет к deadlock, а pthread_cancel или крах всего процесса может оставить блокировку в занятом состоянии
=fixed

20. 16.09.2019. Владимир Губарев. и поток завершает работу
Поток выходит из критической секции?
=fixed

21. 16.09.2019. Владимир Губарев. Пример реализации барьера может быть критическая секция, код которой разрешается выполняться только последнему потоку, запросившему выполнение.
    21.1. Примером реализации барьера?
    =fixed
    21.2. Я правильно понимаю, что предполагается, что мы знаем, сколько потоков должно прийти в барьер?
    =fixed
	
22. 16.09.2019. Владимир Губарев. с. 20. Описание RCU

    22.1. Непонятно, что есть конец работы алгоритма
    Переписать более понятным языком весь абзац.
    =to be discussed internally
    22.2. Замена указателя может быть проведена не только CASом, но и отдельной взаимной блокировкой для писателей или отдельным потоком (например, как сделано в urcu-qsbr) или еще более тяжелой вещью в последних версиях Linux - membarrier(2)
    =fixed
    22.3. Если это имеет смысл, то для интересующихся было бы здорово пояснить, как, почему и когда RCU может быть полезен
    =fixed
	
23. 16.09.2019. Владимир Губарев. с. 21. Например, если мы хотим сделать общую целочисленную переменную для нескольких потоков, нет
смысла создавать mutex или semaphore, более оптимально сделать переменную атомарной. Всегда надо учитывать накладные расходы на создание блокировок и время разработки.
Кажется, надо конкретизировать задачу, т.к. решение неочевидно. Если я правильно понял, имеется в виду атомарный целочисленный счетчик, чтобы что-то считать
=fixed

24. 16.09.2019. Владимир Губарев. Управление количеством нитей.
Может, потоков выполнения?
Целесообразнее использовать thread везде, так как этот термин (в отличие от нить) является более профессиональным
=fixed
-------------------------------------------------
25. 16.09.2019. Владимир Губарев. с. 36. Инструменты измерения времени
Если речь про один хост (даже с несколькими сокетами), то еще можно использовать RDTSC или clock_gettime(CLOCK_MONOTONIC).
walltime подвержен спецэффектам в виде NTP или злого сисадмина, который меняет часы по ходу работы программы.
=to be discuss internally

26. 16.09.2019. Владимир Губарев. Менеджеры управления памятью для параллельных программ
Было бы здорово добавить шикарный многопоточный jemalloc и еще один свежий mimalloc (https://github.com/microsoft/mimalloc)
Найти и добавить более подробное описание
=fixed

27. 16.09.2019. Владимир Губарев. поток1 захватил замок1;
Возможно, дело привычки, но для меня "блокировка" звучит лучше "замка"
=fixed

28. 16.09.2019. Владимир Губарев. В результате получится одна нераспараллеленная программа и десять распараллеленных.
Пять программ? (seq + par-(K1, K2, K3, K4)) = 5
=not needed, already done

29. 18.09.2019. Владимир Губарев. Lock-free алгоритмы

struct data {
2 int volatile nShared1;
3 / padding for cache line=64 byte /
4 char _padding1[64];
5 int volatile nShared2;
6 / padding for cache line=64 byte /
7 char _padding2[64];
8 };

29.1 Паддинги должны быть не 64 байта, а 60, т.к. 4 байта в кэш линии уже занятом intом
Написать прямо со строчкой, которая расположена выше!
=fixed

+ не имеет ли смысла использовать C11 и его атомики вместо volatile?
Переписать весь пример под С11!
=fixed

Подумать над использованием модели памяти языка С11, а не использовании архитектуры. 
=to discuss internally

30. 18.09.2019. Владимир Губарев. Стр. 27.  Чтобы данной проблемы не возникало, следу_ю_ет резмещать по одной переменной в линии.
=fixed

31. 18.09.2019. Владимир Губарев. weak/strong CAS

> Weak версия может вернуть false в случае, когда считанное значение было равно ожидаемому. Strong всегда возвращает правильное значение.

Было бы здорово объяснить, как так может быть и на каких архитектурах, потому что вопрос максимально неочевидный. О том, что это явление существует, говорят все, но на вопрос: "А это почему" - ответ я видел ровно в одной лекции по атомарности (https://www.youtube.com/watch?v=ZQFzMfHIxng)

Это специфичная и продвинутая вещь
Я сам не понимаю!
=to find more information and think

32. 18.09.2019. Владимир Губарев. Разделяемый объект называется lock-free объектом, если он гарантирует, что некоторый поток закончит выполнение операции над объектом за конечное количество шагов вне зависимости от результатов работы других потоков.

Если я правильно понимаю, выполнение lock-free (не wait-free) алгоритма для конкретного потока при определенном везении может никогда не закончиться, если будет постоянно проигрывать конкуренцию за механизм синхронизации а-ля starvation (например, если каждый раз после очередной загрузки актуального значения для CAS его конкурент будет менять значение и, соответственно, поток будет идти на очередную итерацию CAS цикла). 

Верно, на деле описан wait-free алгоритм. Переформулировать.
=to fix

33. 12.09.2019. Александр Пашнин. Пункт 12 1-й лабы. Указан ключ -par-threshold[K], задающий НЕ количество потоков, а вероятность прироста производительности "The intermediate 1 to 99 values represent the percentage probability for profitable speed-up. For example, n=50 directs the compiler to parallelize only if there is a 50% probability of the code speeding up if executed in parallel.". Для задания количества потоков используется ключ -par-num-threads=K (который с дефолтным трэшхолдом ничего параллелить не хочет, ибо невыгодно).
=fixed
22.09.2019. Балакшин П.В. Новый ключ - это уже для OpenMP. В 1-й лабе надо именно попробовать автоматическое распараллеливание.
=not needed

34. 01.10.2019. Владимир Губарев. Во 2-й лабе указать, что библиотека FrameWave достаточно устаревшая (2009 г.) и вместо неё имеет смысл попробовать использовать:
-ATLAS (для этого выключить троттлинг и энергосбережение, а также разобраться как менять число потоков)
-Intel Integrated Performance Primitives
01.10.2019. Балакшин П.В. Верно. Добавить.
=fixed

35. 29.10.2019. Алексей Мишенёв. Список литературы, 16 элемент "Википедия. Модель акторов". Некорректная ссылка
=fixed

36. 29.10.2019. Алексей Мишенёв. Заменить изображения с исходным кодом на, собственно, код:
  * images/CAS.png
  * images/OpenCLContextExample.png
  * images/OpenCLKernelExample.png
=to fix
  
37. 29.10.2019. Алексей Мишенёв. По-хорошему, стоит заменить вырвиглазные картинки по типу images/lockFreeQueue.png либо на *.svg, либо на TikZ
=in discuss

38. 6.04.2021. Пушкарев Даниил. Добавлен подраздел ICC.
=fixed

39. 7.04.2021. Пушкарев Даниил. Неверный ключ компиляции openmp для ICC. Неверный тип данных в секции 1.2 __thread int.
=fixed
40. 7.04.2021. Пушкарев Даниил. Ключи распараллеливания для лабораторной работы 1 дополнительный пункт компилятора ICC неверны. Функция SetNumThreads(M) в лабораторной работе 2 при использовании ICC не работает, необходимо добавить примечание о компиляции под разное количество потоков
=fixed

41. 7.04.2021. Пушкарев Даниил. Добавлены файлы кода для замены изображений заявленные в бэклоге №36. Если устроит, можно заменить изображения.
=in discuss

42. 17.05.2021. Балакшин П.В. Лаб 1:
Надо указывать в отчёте размер кэша
Гистограммы - лучше
Лаб1 - в отчёт добавить значения X (поменять цикл до значения 5 вместо 100 и сделать printf): 5 значения для последов. + 5 для параллельной.
Лаб1 - число потоков в том числе должно быть больше, чем число физических ядер (т.е. в т.ч. число потоков было НЕ кратно число ядер)
ДЛЯ ВОПРОСОВ: clang - как посчитать число потоков, которые решил создать компилятор
Ключ -lm для матем. функций
Для виртуалки - не менее 2 ядер
Не менялось условие по электроэнергии

43. 17.05.2021. Балакшин П.В. Лаб 2:
ДЛЯ ВОПРОСОВ: Указать, сколько всего потоков можно создать (или всё же начиная с 3-й?) - как узнать, с помощью GCC - это вопрос

44. 17.05.2021. Балакшин П.В. Лаб 3:
Указать, сколько всего потоков можно создать - надо указывать в отчёте
Сделать сравнение с default chuck size. Нужно знать, какой он на конкретной машине
ДЛЯ ВОПРОСОВ: Как доказать 11-е задание (доп №2), что работает независимо от расписаний

45. TO CLARIFY 17.05.2021. Балакшин П.В. Лаб 4:
Текст задания:
"

TO CLARIFY THIS LINE: На каждой итерации i перед вызовом rand_r можно вызывать функцию srand(f(i))

4. Написать функцию, которая один раз в секунду выводит в консоль сообщение о текущем проценте завершения работы программы. Указанную функцию необходимо запустить вотдельном потоке, параллельно работающем с основным вычислительным циклом. Отдельный поток 4-м или 5-м?
5. Ключи сильно будут влиять на прямую совместимость. Можно отключить omp отдельным ключом.
"

Пункт 4. Именно на OpenMP. Но при этом, если нет OpenMP, функция должна/не должна работать

46. 17.05.2021. Балакшин П.В. Ко всем лабам.
Добавить вопросы.

47. 17.05.2021. Балакшин П.В.
Вернуть число экспериментов до 100 и проверить везде (например, лаб 4).

48. 17.05.2021. Балакшин П.В. Теория и лаба 3:
В документации в разделе указано 2.7.1.1, что если стратегия не указана, то используется переменная def-sched-var из ICV. Данная переменная зависит от реализации OpenMP, у нас на машине устанавливается dynamic, у некоторых в интернетах static.

49. TO CLARIFY  WITH DMITRY 18.05.2021. Балакшин П.В.
Для OpenCL добавить вопрос в лабу о printf (https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/printfFunction.html)

50. 18.05.2021. Балакшин П.В.
Вопрос для лабы 2: Как посчитать долю кода, который можно распараллелить, если известны ускорение и число потоков.
Если использовать утилиты.

51. 21.05.2021. Балакшин П.В.
Написать про Valgrind. Раздел про профилировщики. В главу 2.

52. 15.08.2021. Балакшин П.В.
Лаба 1, п.7. Время для N1 указать 0.1 секунд, а для N2 - 5 секунд.

53. 15.08.2021. Балакшин П.В.
Лаба 4, п.3. Сделать допзаданием слияние двух отсортированных частей массива. Подумать над алгоритмами для сортировки, чтобы можно было использовать везде, в то силе при слиянии.

54. 52. 15.08.2021. Балакшин П.В.
Лаба 4, п.4. Указать, что нельзя использовать PThreads, сделать только средствами OpenMP.
=fixed
